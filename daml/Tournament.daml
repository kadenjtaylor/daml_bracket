module Tournament where

import DA.Map (null, size, fromList, delete, empty, insert, values, Map, lookup, toList)
import DA.Foldable (foldMap, Foldable(maximum))
import DA.Optional (catOptionals, isNone, mapOptional)

type MatchIndex = Int

data MatchRef
  = PartyRef with
    p: Party
  | IndexRef with
    index: MatchIndex
  deriving (Eq, Show, Ord)

data Match
  = Bye with
    p: MatchRef
  | Vs with
    p1: MatchRef
    p2: MatchRef
      deriving (Eq, Show)

data PartialBracket = PartialBracket with
  round: [MatchIndex]
  matches: Map MatchIndex Match
    deriving (Eq, Show)

data Bracket
  = Empty
  | NonEmpty with
      root: MatchIndex
      matches: Map MatchIndex Match
    deriving (Eq, Show)

data MatchReport = MatchReport with
  index: MatchIndex
  winner: Party
    deriving (Eq, Show)

data BracketUpdateError
  = BracketEmpty
  | PlayerNotActive with
    id: MatchIndex
    p: Party
  | NoSuchMatch with
    id: MatchIndex
  | MatchNotReady with
    matchId: MatchIndex
    blocking: [MatchIndex]
  | UnknownError with
    msg: Text
      deriving (Eq, Show)

data ReportResult
  = Finished with
    winner: Party
  | Next with
    b: Bracket
  | Error with
    err: BracketUpdateError

-- ========================================================

bracketize: [Party] -> Bracket
bracketize [] = Empty
bracketize ps = finalize $ toPartial $ matchUp ps

matchUp: [Party] -> [Match]
matchUp [] = []
matchUp [p] = [Bye (PartyRef p)]
matchUp (p1 :: p2 :: rest) = Vs (PartyRef p1) (PartyRef p2) :: matchUp rest

nextIndex: [MatchIndex] -> MatchIndex
nextIndex [] = 0
nextIndex indicies = maximum indicies + 1

finalize: PartialBracket -> Bracket
finalize (PartialBracket [] m) = Empty
finalize (PartialBracket [i] m) = NonEmpty with
  root = i
  matches = m
finalize (PartialBracket (i1 :: i2 :: rest) matches) =
  do
  let i = nextIndex (i1 :: i2 :: rest)
      nextMatch = Vs (IndexRef i1) (IndexRef i2)
  finalize PartialBracket with
    round = rest ++ [i]
    matches = insert i nextMatch matches

toPartial: [Match] -> PartialBracket
toPartial ms = foldl load emptyPartial ms

emptyPartial : PartialBracket
emptyPartial = PartialBracket with
  round = []
  matches = empty

load: PartialBracket -> Match -> PartialBracket
load (PartialBracket r m) toLoad =
  do
  let i = nextIndex r
  PartialBracket with
    round = r ++ [i]
    matches = insert i toLoad m

-- ========================================================
--      Extra Bit for Debugging / Data Egress
-- ========================================================

-- TODO: Add MatchIndex to ActiveMatch
-- That way we can generate a Matchreport externally
data ActiveMatch
  = ActiveBye with
    p: Party
  | ActiveVs with
    p1: Party
    p2: Party
      deriving (Eq, Show)

toActive: Match -> Optional ActiveMatch
toActive m = case m of
  Vs (PartyRef p1) (PartyRef p2) -> Some $ ActiveVs p1 p2
  Bye(PartyRef p) -> Some $ ActiveBye p
  _ -> None

activeMatches: Bracket -> [ActiveMatch]
activeMatches b = mapOptional toActive (values b.matches)

-- ========================================================

indexRefsOf: Match -> [MatchIndex]
indexRefsOf (Bye (IndexRef i)) = [i]
indexRefsOf (Vs (IndexRef i1) (IndexRef i2)) = [i1, i2]
indexRefsOf (Vs (IndexRef i1) _) = [i1]
indexRefsOf (Vs _ (IndexRef i2)) = [i2]
indexRefsOf _ = []

partyRefsOf: Match -> [Party]
partyRefsOf (Bye (PartyRef p)) = [p]
partyRefsOf (Vs (PartyRef p1) (PartyRef p2)) = [p1, p2]
partyRefsOf (Vs (PartyRef p1) _) = [p1]
partyRefsOf (Vs _ (PartyRef p2)) = [p2]
partyRefsOf _ = []

isWellFormed: Bracket -> Bool
isWellFormed Empty = True
isWellFormed (NonEmpty root matches) = formCheck ([root], matches)

formCheck: ([MatchIndex], Map MatchIndex Match) -> Bool
formCheck ([], m) | DA.Map.null m = True
formCheck ([], _) = False
formCheck (indicies, m) = do
  let stuff = map (`DA.Map.lookup` m) indicies
  not (any isNone stuff) &&
    (do let nextRefs = foldMap indexRefsOf (catOptionals stuff)
        let nextMap = foldl deleteStep m indicies
        formCheck (nextRefs, nextMap))
      
deleteStep: Ord k => Map k v -> k -> Map k v
deleteStep m k = delete k m

playersIn: Bracket -> [Party]
playersIn Empty = []
playersIn (NonEmpty root matches) = foldMap partyRefsOf (values matches)

-- TODO: Clean
alterIfDependentOn: MatchReport -> (MatchIndex, Match) -> (MatchIndex, Match)
alterIfDependentOn (MatchReport reportIndex winner) (matchindex, m@(Vs (IndexRef i) ref))
  | reportIndex == i = (matchindex, Vs (PartyRef winner) ref)
alterIfDependentOn (MatchReport reportIndex winner) (matchindex, m@(Vs ref (IndexRef i)))
  | reportIndex == i = (matchindex, Vs ref (PartyRef winner))
alterIfDependentOn (MatchReport reportIndex winner) (matchindex, m@(Bye (IndexRef i)))
  | reportIndex == i = (matchindex, Bye (PartyRef winner))
alterIfDependentOn (MatchReport reportIndex winner) (matchindex, m) = (matchindex, m)

-- TODO: Clean
applyReport: Bracket -> MatchReport -> ReportResult
applyReport Empty _ = Error BracketEmpty
applyReport (NonEmpty root matches) report@(MatchReport index winner) =
  case (DA.Map.lookup index matches) of
    -- The only cases we really care about
    Some(Bye(PartyRef p)) ->
      if p == winner then
        if root == index then
          Finished winner
        else
          do
            let m = delete index matches
                pairs = toList m
                updated = map (alterIfDependentOn report) pairs
                newMatches = fromList updated
            Next $ (NonEmpty root newMatches)
      else
        Error $ PlayerNotActive index winner
    Some(Vs (PartyRef p1) (PartyRef p2)) ->
      if p1 == winner || p2 == winner then
        if root == index then
          Finished winner
        else
          do
            let m = delete index matches
                pairs = toList m
                updated = map (alterIfDependentOn report) pairs
                newMatches = fromList updated
            Next $ (NonEmpty root newMatches)
      else
        Error $ PlayerNotActive index winner
    -- Dealing with inactive/missing matches
    Some(Bye(IndexRef i)) -> Error $ MatchNotReady index [i]
    Some(Vs (IndexRef i1) (IndexRef i2)) -> Error $ MatchNotReady index [i1, i2]
    Some(Vs (_) (IndexRef i)) -> Error $ MatchNotReady index [i]
    Some(Vs (IndexRef i) (_)) -> Error $ MatchNotReady index [i]
    None -> Error $ NoSuchMatch index

type TrophyId = ContractId Trophy

template Trophy
  with
    judge: Party
    winner: Party
  where
    signatory judge
    observer [judge, winner]

type TournamentId = ContractId Tournament

template Tournament
  with
    judge: Party
    bracket: Bracket
  where
    ensure isWellFormed bracket
    signatory judge
    observer playersIn bracket
  
    choice Report: Either TrophyId TournamentId
      with
        report: MatchReport
      controller judge
      do
        case (applyReport bracket report) of
          Finished winner -> do
            trophyId <- create (Trophy judge winner)
            return $ Left trophyId
          Next newBracket -> do
            tournamentId <- create (this with bracket = newBracket)
            return $ Right tournamentId
          Error msg -> error (show msg)

    nonconsuming choice ActiveMatches: [ActiveMatch]
      with
      controller judge
      do return $ activeMatches bracket